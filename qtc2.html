<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QTC Protocol – Quantum-Safe Bitcoin Evolution</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  /* ---------- RESET / BASE ---------- */
  *{margin:0;padding:0;box-sizing:border-box;font-family:'Segoe UI',Roboto,'Helvetica Neue',Arial,system-ui,sans-serif}
  html,body{width:100%;background:#00000080;color:#fff;overflow-x:hidden}

  /* ---------- BACKGROUND CANVAS ---------- */
  #bgCanvas{position:fixed;inset:0;z-index:-1}

  /* ---------- SECTIONS ---------- */
  section{position:relative;z-index:2;min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:4rem 2rem}
  h1,h2{font-weight:800;letter-spacing:.05em;background:linear-gradient(90deg,#00faff,#55ffff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:1rem}
  p{max-width:700px;margin:0 auto 2rem;color:#cceeff;line-height:1.6}
  .btn{padding:.8rem 1.6rem;border:2px solid #00faff;border-radius:4px;background:transparent;color:#00faff;font-weight:600;text-decoration:none;transition:all .3s}
  .btn:hover{background:#00faff;color:#000}

  /* ---------- NAV ---------- */
  nav{position:fixed;top:0;left:0;right:0;display:flex;align-items:center;justify-content:space-between;padding:1rem 2rem;z-index:10;background:rgba(0,0,0,.6);backdrop-filter:blur(4px)}
  nav h1{font-size:1.5rem;font-weight:700;letter-spacing:.05em;background:linear-gradient(90deg,#00faff,#55ffff);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
  nav a{color:#fff;margin-left:1.5rem;text-decoration:none;font-weight:500;transition:color .2s}
  nav a:hover{color:#00faff}
  #bgCanvas{position:fixed; inset:0; z-index:-1; pointer-events:none}
</style>
</head>

<body>
<canvas id="bgCanvas"></canvas>

<nav>
  <h1>QTC</h1>
  <div>
    <a href="#intro">Intro</a>
    <a href="#tech">Tech</a>
    <a href="#roadmap">Roadmap</a>
    <a href="https://qtcprotocol.com" target="_blank">Website</a>
    <a href="https://qtcexplorer.com" target="_blank">Explorer</a>
    <a href="https://github.com/qtcprotocol" target="_blank">GitHub</a>
  </div>
</nav>

<!-- SECTION 1 -->
<section id="intro">
  <h1>Quantum-Safe Bitcoin Evolution</h1>
  <p>QTC is a post-quantum hard-fork of Bitcoin that replaces ECDSA with <strong>Kyber1024</strong> (KEM) and <strong>Dilithium3</strong> (signatures) to survive the quantum age.</p>
  <a class="btn" href="#tech">Discover More</a>
</section>

<!-- SECTION 2 -->
<section id="tech">
  <h2>Post-Quantum Cryptography</h2>
  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer pharetra velit quis nisl sodales, et elementum elit faucibus. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Proin ut vestibulum nulla.</p>
  <p>Kyber1024 provides IND-CCA2-secure key encapsulation while Dilithium3 offers strong signature security based on lattice hardness assumptions—both NIST-selected algorithms.</p>
</section>

<!-- SECTION 3 -->
<section id="roadmap">
  <h2>Roadmap & Resources</h2>
  <p>Phase 1: Research & Whitepaper<br>Phase 2: Testnet Launch<br>Phase 3: Security Audit<br>Phase 4: Mainnet Deployment</p>
  <a class="btn" href="https://github.com/qtcprotocol" target="_blank">Browse GitHub</a>
  <a class="btn" href="https://qtcexplorer.com" target="_blank">Open Explorer</a>
</section>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/* ======================================================
   BASIC SETUP
====================================================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(
  45, window.innerWidth / window.innerHeight, 0.1, 2000
);
camera.position.z = 9;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);


/* ======================================================
   COLOR GRADIENT: Deep blue → electric → cyan glow
====================================================== */
const palette = [
  0x0022ff, 0x0044ff, 0x0066ff, 0x0088ff, 0x0099ff,
  0x00bbff, 0x00ddff, 0x00faff, 0x33ffff, 0x55ffff,
  0x77ffff
];

/* ======================================================
   FUNCTION: Create a single neon cube with glow effect
====================================================== */
function makeNeonCube(size, color) {
  const geom = new THREE.BoxGeometry(size, size, size);
  const edges = new THREE.EdgesGeometry(geom);

  // Main neon line material
  const mat = new THREE.LineBasicMaterial({
    color,
    transparent:true,
    opacity:0.95,
    blending: THREE.AdditiveBlending,
    depthWrite:false,
    linewidth:2
  });

  const lineMesh = new THREE.LineSegments(edges, mat);

  // Add glow effect using a slightly larger transparent cube
  const glowGeom = new THREE.BoxGeometry(size * 1.1, size * 1.1, size * 1.1);
  const glowMat = new THREE.MeshBasicMaterial({
    color: color,
    transparent: true,
    opacity: 0.1,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  const glowMesh = new THREE.Mesh(glowGeom, glowMat);
  
  // Combine both effects
  const group = new THREE.Group();
  group.add(lineMesh);
  group.add(glowMesh);
  
  return group;
}


/* ======================================================
   CREATE OUTER + INNER rotating cube clusters
====================================================== */
const outerGroup = new THREE.Group();
scene.add(outerGroup);

const innerGroup = new THREE.Group();
scene.add(innerGroup);

const OUTER_COUNT = 20;
const INNER_COUNT = 15;

// sizes
const outerBase = 3.2;
const innerBase = 1.3;

// track cubes for animation
let outerCubes = [];
let innerCubes = [];


/* ---------- Create OUTER cubes ---------- */
for (let i = 0; i < OUTER_COUNT; i++) {
  const size = outerBase * (1 - i * 0.045);
  const col = palette[i % palette.length];

  const cube = makeNeonCube(size, col);

  cube.userData.rx = Math.random() * 2;
  cube.userData.ry = Math.random() * 2;
  cube.userData.rz = Math.random() * 2;

  outerGroup.add(cube);
  outerCubes.push(cube);
}


 /* ---------- Create INNER cubes ---------- */
for (let i = 0; i < INNER_COUNT; i++) {
  const size = innerBase * (1 - i * 0.06);
  const col = palette[(i + 4) % palette.length];

  const cube = makeNeonCube(size, col);

  cube.userData.rx = Math.random() * 3;
  cube.userData.ry = Math.random() * 3;
  cube.userData.rz = Math.random() * 3;

  innerGroup.add(cube);
  innerCubes.push(cube);
}


/* ======================================================
   ANIMATION LOOP
====================================================== */
function animate(t) {
  t *= 0.001;

  // flattening cycle: 0 → 1 → 0 repeating
  const phase = (Math.sin(t * 1.6) + 1) / 2;
  const flatten = Math.pow(phase, 3);  // smoother transition

  /* ---- Animate outer cubes ---- */
  outerCubes.forEach((cube, i) => {
    const speed = 0.08 + i * 0.004; // slowed a touch more from 0.1

    // independent 3D rotations
    cube.rotation.x = cube.userData.rx * t * speed * (1 - flatten);
    cube.rotation.y = cube.userData.ry * t * speed * (1 - flatten);
    cube.rotation.z = cube.userData.rz * t * speed * (1 - flatten);

    // when flatten=1, cubes return to square
    cube.rotation.x *= (1 - flatten);
    cube.rotation.y *= (1 - flatten);
    cube.rotation.z += flatten * 0.0;
  });

  /* ---- Animate inner core cubes ---- */
  innerCubes.forEach((cube, i) => {
    const speed = 0.16 + i * 0.008; // slowed a touch more from 0.2

    cube.rotation.x = cube.userData.rx * t * speed * (1 - flatten);
    cube.rotation.y = cube.userData.ry * t * speed * (1 - flatten);
    cube.rotation.z = cube.userData.rz * t * speed * (1 - flatten);
  });

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();


/* ======================================================
   RESIZE
====================================================== */
window.addEventListener("resize", () => {
  const w = window.innerWidth;
  const h = window.innerHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
});
</script>

<!--
  Below: small added script (only this section is new).
  - It uses anime.js to apply Option B (twist & shear) once the user scrolls.
  - The original cube code above is left exactly as you uploaded.
-->
<script>
(function(){
  // throttle updates so anime is not spammed; only run when scroll changes
  let lastProgress = 0;
  let ticking = false;

  function onScroll() {
    if (ticking) return;
    ticking = true;
    requestAnimationFrame(() => {
      const scroll = document.documentElement.scrollTop || document.body.scrollTop;
      const max = document.body.scrollHeight - window.innerHeight;
      const progress = Math.max(0, Math.min(1, (max > 0) ? scroll / max : 0));

      // only start animation after user actually scrolls (progress > 0)
      if (progress > 0) {
        // Map progress → twist amount (radians). Cap to avoid over-rotation.
        const targetY = progress * 3.0;   // twist torque on Y axis
        const targetX = progress * 1.5;   // smaller twist on X axis (shear feel)

        // Use anime.js to smoothly animate to target rotation
        anime.remove(outerGroup.rotation); // clear any running anime on the target
        anime({
          targets: outerGroup.rotation,
          y: targetY,
          x: targetX,
          duration: 450,
          easing: 'easeOutQuad'
        });

        // Slight complementary twist for innerGroup for depth
        anime.remove(innerGroup.rotation);
        anime({
          targets: innerGroup.rotation,
          y: targetY * 0.6,
          x: targetX * 0.6,
          duration: 600,
          easing: 'easeOutQuad'
        });
      } else {
        // if user scrolls back to top, return to neutral smoothly
        anime.remove(outerGroup.rotation);
        anime({
          targets: outerGroup.rotation,
          y: 0,
          x: 0,
          duration: 650,
          easing: 'easeOutQuad'
        });
        anime.remove(innerGroup.rotation);
        anime({
          targets: innerGroup.rotation,
          y: 0,
          x: 0,
          duration: 700,
          easing: 'easeOutQuad'
        });
      }

      lastProgress = progress;
      ticking = false;
    });
  }

  // Only attach listener (and start applying) — anime triggers only when user scrolls.
  window.addEventListener('scroll', onScroll, { passive:true });
})();
</script>

</body>
</html>
